package umc.spring.apiPayload.code;

// 먼저 두 개의 인터페이스인 BaseCode와 BaseErrorCode의 역할은
// 이를 구체화 하는 Status에서
// 두 개의 메소드를 반드시 Override할 것을 강제한다.
public interface BaseCode {
// interface
// - 단지 추상 메서드들을 나열한 형태이다.
// - interface의 추상 메서드들의 나열은
// 클래스나 프로그램이 제공하는 기능을 명시적으로 선언한 형태이다.
// 이 명세를 보고 클라이언트 프로그램은 선언되어있는 명세만 보고
// 이를 구현한 클래스를 사용할 수 있다.
// - interface 클래스를 정의할 때 틀을 제공한다.
// 즉, 객체를 만들 때 어떻게 구성해야 하는지에 대한 설계도 틀이다.
// 공통적인 틀을 제공하기 때문에 공통 목적을 갖는 클래스들의 기능을
// 일관되게 표준화시킬 수 있다.
// - 자식 클래스는 부모 클래스를 상속한다.
// 하지만 인터페이스는 "구현한다"라고 한다.
// 어떤 클래스가 어떤 인터페이스를 구현한다는 것을
// "그 인터페이스 타입"이라고 한다.
// - 클래스들 사이에서 중간 매개역할을 한다.
// - 정리해보자면 interface는 클라이언트 프로그램에서
// 구현을 보지 않고도 객체를 사용할 수 있는 매개체 역할을 하고,
// 공통적인 목적을 갖고있는 클래스들의 틀을 제공하는 역할을 한다.

// API 응답에 들어갈 message의 형식

    public ReasonDTO getReason();

    public ReasonDTO getReasonHttpStatus();

    // - interface는 공개가 목적이기 때문에 접근 지정자는 public밖에 없다.
    // public을 하지 않으면 interface가 있는 package 내에서만
    // 사용이 가능하다.
    // - interface는 구현코드가 없기 때문에
    // 멤버 변수를 갖고 있을 수 없고 상수화된다.
    // 모든 변수는 따로 지정하지 않아도 public static final로 컴파일된다.
    // - 모든 메서드 또한 따로 지정하지 않아도
    // public abstract로 컴파일된다.
    // 컴파일러(java.exe)를 통해
    // 바이트 코드 형태의 .class 파일로 컴파일된다.
    // Java8 이후부터는
    // default method, static method,
    // private 메서드(Java 9 이후) 선언이 가능해졌기 때문에
    // 일부 구현 코드가 있다.

    // default method : 구현을 갖는 메서드
    // - 인터페이스를 구현하는 클래스들에서
    // 공통으로 사용할 수 있는 기본 메서드
    // - 구현하는 클래스에서 재정의도 가능하다.
    // - 당연히 인터페이스를 구현한 클래스의 인스턴스가 생성되어야
    // 사용 가능하다.
    // - public을 명시적으로 사용하지 않아도
    // compile time에 자동으로 선언된다.
    // static method : 인스턴스 생성과 상관 없이 인터페이스 타입으로 사용
    // - 만약 많은 인스턴스에서 중복으로 쓰이는 메서드가 있는 경우,
    // 이를 중복적으로 인스턴스에서 만들어야 하므로 비효율적이다.
    // static 메서드를 만들면 공통으로 사용할 수 있다.
    // private method : Java 9 이후
    // - 인터페이스를 구현한 클래스에서 사용하거나 재정의 할 수 있다.
    // - 인터페이스 내부에서만 사용하기 위해 구현하는 메서드
    // - default 메서드나 static 메서드에서 사용하기 위해 구현한다.

    // 인터페이스 구현
    // - 인터페이스는 구현 코드가 없고
    // 클래스가 이 인터페이스를 "구현한다"라고 한다.
    // - 코드에서 인터페이스의 메서드를 호출하면
    // 인터페이스는 구현 객체의 메서드를 찾아서 호출한다.
    // - 그리고 객체는 추상 메서드를 구현한 메서드를 갖고 있어야 한다.
    // 이 객체를 구현 객체라고 한다.
    // - 구현 객체를 생성하는 클래스는 구현 클래스라고 한다.
    // - 인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로
    // 형 변환을 할 수 있다.
    // ex) Calc calc = new CompleteCalc();
    // CompleteCalc는 Calc 인터페이스를 구현한 클래스이고
    // Calc는 interface이다.

}
